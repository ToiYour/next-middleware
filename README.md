# Next.js Middleware & API System Documentation

## üìã T·ªïng quan

H·ªá th·ªëng middleware v√† API client ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ gi·∫£i quy·∫øt c√°c v·∫•n ƒë·ªÅ ph·ª©c t·∫°p trong vi·ªác x√°c th·ª±c, ·ªßy quy·ªÅn v√† proxy API calls trong Next.js. ƒê√¢y l√† m·ªôt ki·∫øn tr√∫c modular, scalable v√† type-safe.

## üèóÔ∏è Ki·∫øn tr√∫c t·ªïng th·ªÉ

```
Request ‚Üí Token Middleware ‚Üí Auth Middleware ‚Üí Role Middleware ‚Üí Proxy Middleware ‚Üí Backend API
    ‚Üì           ‚Üì                ‚Üì                ‚Üì                ‚Üì
 Refresh      Verify          Check           Forward          Response
 Token        Token           Role            Request
```

## üîß Chi ti·∫øt t·ª´ng Middleware

### 1. Token Middleware (`tokenApiMiddleware`)

#### **M·ª•c ƒë√≠ch:**
- T·ª± ƒë·ªông refresh access token khi h·∫øt h·∫°n
- ƒê·∫£m b·∫£o token lu√¥n valid cho c√°c middleware ti·∫øp theo
- X·ª≠ l√Ω token lifecycle m·ªôt c√°ch transparent

#### **C√°ch ho·∫°t ƒë·ªông:**
```typescript
export const tokenApiMiddleware: IMiddleware = {
  matcher: /.*/, // √Åp d·ª•ng cho m·ªçi request
  excluded: /^$/, // Kh√¥ng lo·∫°i tr·ª´ g√¨
  
  handle: async (req, res, context) => {
    // 1. L·∫•y token t·ª´ cookie
    const accessToken = req.cookies.get('accessToken')?.value
    const refreshToken = req.cookies.get('refreshToken')?.value
    
    // 2. Ki·ªÉm tra token c√≥ h·∫øt h·∫°n kh√¥ng
    if (accessToken && !isExpired(accessToken)) {
      context.accessToken = accessToken // L∆∞u v√†o context
      return res
    }
    
    // 3. Refresh token n·∫øu c·∫ßn
    if (refreshToken) {
      const newToken = await refreshAccessToken(refreshToken)
      context.accessToken = newToken // L∆∞u token m·ªõi v√†o context
      res.cookies.set('accessToken', newToken) // Set cookie cho client
    }
    
    return res
  }
}
```

#### **T·∫°i sao c·∫ßn Token Middleware:**
- **V·∫•n ƒë·ªÅ:** Access token c√≥ th·ªùi gian s·ªëng ng·∫Øn (15-30 ph√∫t), n·∫øu h·∫øt h·∫°n s·∫Ω b·ªã 401
- **Gi·∫£i ph√°p:** T·ª± ƒë·ªông refresh tr∆∞·ªõc khi request ƒë·∫øn backend
- **L·ª£i √≠ch:** User kh√¥ng bao gi·ªù b·ªã logout ƒë·ªôt ng·ªôt, UX m∆∞·ª£t m√†

### 2. Auth Middleware (`authApiMiddleware`)

#### **M·ª•c ƒë√≠ch:**
- Verify user ƒë√£ login ch∆∞a
- Redirect ƒë·∫øn login page n·∫øu ch∆∞a auth
- B·∫£o v·ªá c√°c route c·∫ßn authentication

#### **C√°ch ho·∫°t ƒë·ªông:**
```typescript
export const authApiMiddleware: IMiddleware = {
  matcher: /^\/admin/, // Ch·ªâ √°p d·ª•ng cho /admin routes
  excluded: /^\/login$/, // Lo·∫°i tr·ª´ login page
  
  handle: async (req, res, context) => {
    // 1. L·∫•y token t·ª´ context (ƒë√£ ƒë∆∞·ª£c refresh ·ªü middleware tr∆∞·ªõc)
    const accessToken = context.accessToken || req.cookies.get('accessToken')?.value
    
    // 2. Redirect n·∫øu kh√¥ng c√≥ token
    if (!accessToken) {
      return NextResponse.redirect('/login')
    }
    
    // 3. Verify token validity
    const payload = parseJWT(accessToken)
    if (payload.exp < now()) {
      return NextResponse.redirect('/login')
    }
    
    // 4. L∆∞u user info v√†o context cho middleware ti·∫øp theo
    context.user = payload
    return res
  }
}
```

#### **T·∫°i sao c·∫ßn Auth Middleware:**
- **V·∫•n ƒë·ªÅ:** C·∫ßn ki·ªÉm tra authentication cho nhi·ªÅu routes
- **Gi·∫£i ph√°p:** Centralized authentication logic
- **L·ª£i √≠ch:** Code clean, d·ªÖ maintain, consistent security

### 3. Role Middleware (`roleMiddleware`)

#### **M·ª•c ƒë√≠ch:**
- Ki·ªÉm tra user c√≥ quy·ªÅn truy c·∫≠p route kh√¥ng
- Implement fine-grained authorization
- B·∫£o v·ªá admin routes

#### **C√°ch ho·∫°t ƒë·ªông:**
```typescript
export const roleMiddleware: IMiddleware = {
  matcher: /^\/admin\/(users|settings)/, // Ch·ªâ admin routes nh·∫°y c·∫£m
  excluded: /^$/,
  
  handle: async (req, res, context) => {
    // 1. L·∫•y user info t·ª´ context (ƒë√£ ƒë∆∞·ª£c verify ·ªü auth middleware)
    const user = context.user
    
    // 2. Ki·ªÉm tra role
    if (user.role !== 'admin') {
      return NextResponse.redirect('/unauthorized')
    }
    
    // 3. C√≥ th·ªÉ ki·ªÉm tra permissions chi ti·∫øt h∆°n
    if (req.nextUrl.pathname.includes('/users') && !user.permissions.includes('user.manage')) {
      return NextResponse.redirect('/forbidden')
    }
    
    return res
  }
}
```

#### **T·∫°i sao c·∫ßn Role Middleware:**
- **V·∫•n ƒë·ªÅ:** Kh√¥ng ph·∫£i user n√†o c≈©ng c√≥ quy·ªÅn truy c·∫≠p m·ªçi resource
- **Gi·∫£i ph√°p:** Role-based access control (RBAC)
- **L·ª£i √≠ch:** Security t·ªët h∆°n, scalable cho enterprise apps

### 4. Proxy Middleware (`proxyApiMiddleware`)

#### **M·ª•c ƒë√≠ch:**
- Proxy API calls t·ª´ frontend ƒë·∫øn backend
- T·ª± ƒë·ªông inject access token v√†o headers
- Gi·∫£i quy·∫øt CORS issues

#### **C√°ch ho·∫°t ƒë·ªông:**
```typescript
export const proxyApiMiddleware: IMiddleware = {
  matcher: /^\/api\//, // Ch·ªâ √°p d·ª•ng cho /api routes
  excluded: /^\/api\/(auth|health)$/, // Lo·∫°i tr·ª´ auth routes
  
  handle: async (req, res, context) => {
    // 1. L·∫•y token t·ª´ context (ƒë√£ fresh t·ª´ token middleware)
    const accessToken = context.accessToken || req.cookies.get('accessToken')?.value
    
    // 2. T·∫°o target URL
    const pathName = req.nextUrl.pathname.replace(/^\/api\//, '')
    const target = new URL(`${process.env.API_URL}/${pathName}`)
    
    // 3. Copy headers v√† inject token
    const headers = new Headers(req.headers)
    if (accessToken) {
      headers.set('Authorization', `Bearer ${accessToken}`)
    }
    
    // 4. Rewrite request ƒë·∫øn backend
    return NextResponse.rewrite(target, { headers })
  }
}
```

#### **T·∫°i sao c·∫ßn Proxy Middleware:**
- **V·∫•n ƒë·ªÅ:** Frontend g·ªçi API tr·ª±c ti·∫øp c√≥ nhi·ªÅu issues:
  - CORS problems
  - Token management ph·ª©c t·∫°p
  - Security risks (expose API endpoints)
- **Gi·∫£i ph√°p:** Proxy qua Next.js middleware
- **L·ª£i √≠ch:** 
  - Automatic token injection
  - Hide backend URLs
  - Centralized request handling

## üîÑ Context System

### **Context l√† g√¨:**
```typescript
interface MiddlewareContext {
  accessToken?: string | null
  refreshToken?: string | null
  user?: any
  [key: string]: any
}
```

### **T·∫°i sao c·∫ßn Context:**
- **V·∫•n ƒë·ªÅ:** Middleware ch·∫°y tu·∫ßn t·ª± nh∆∞ng kh√¥ng share data
- **Gi·∫£i ph√°p:** Context object ƒë∆∞·ª£c truy·ªÅn qua c√°c middleware
- **L·ª£i √≠ch:** Token ƒë∆∞·ª£c refresh ·ªü middleware ƒë·∫ßu, middleware sau d√πng lu√¥n

### **Flow v·ªõi Context:**
```
1. Token Middleware: context.accessToken = freshToken
2. Auth Middleware: token = context.accessToken (kh√¥ng ph·∫£i cookie c≈©)
3. Role Middleware: user = context.user
4. Proxy Middleware: token = context.accessToken
```

## üåê API Client System

### 1. Client Fetch (`clientFetch`)

#### **M·ª•c ƒë√≠ch:**
- G·ªçi API t·ª´ browser (client-side)
- S·ª≠ d·ª•ng proxy middleware ƒë·ªÉ forward request

#### **C√°ch ho·∫°t ƒë·ªông:**
```typescript
export async function clientFetch<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  // 1. G·ªçi ƒë·∫øn /api route (s·∫Ω ƒë∆∞·ª£c proxy middleware x·ª≠ l√Ω)
  const url = `/api${endpoint}`
  
  // 2. Fetch v·ªõi default options
  const response = await fetch(url, {
    headers: { 'Content-Type': 'application/json' },
    ...options
  })
  
  // 3. Handle response
  const data = await response.json()
  if (!response.ok) throw new Error(data.message)
  
  return data
}
```

#### **T·∫°i sao c·∫ßn clientFetch:**
- **V·∫•n ƒë·ªÅ:** Browser kh√¥ng th·ªÉ g·ªçi tr·ª±c ti·∫øp backend API (CORS, token)
- **Gi·∫£i ph√°p:** G·ªçi qua Next.js API routes ‚Üí proxy middleware x·ª≠ l√Ω
- **L·ª£i √≠ch:** Transparent API calls, automatic token handling

### 2. Server Fetch (`serverFetch`)

#### **M·ª•c ƒë√≠ch:**
- G·ªçi API t·ª´ server-side (SSR, SSG)
- Bypass middleware, g·ªçi tr·ª±c ti·∫øp backend

#### **C√°ch ho·∫°t ƒë·ªông:**
```typescript
export async function serverFetch<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
  // 1. G·ªçi tr·ª±c ti·∫øp backend API
  const url = `${process.env.API_URL}${endpoint}`
  
  // 2. L·∫•y token t·ª´ server cookies
  const cookieStore = await cookies()
  const accessToken = cookieStore.get('accessToken')?.value
  
  // 3. Inject token v√†o headers
  const headers = new Headers(options.headers)
  if (accessToken) {
    headers.set('Authorization', `Bearer ${accessToken}`)
  }
  
  // 4. Fetch v·ªõi token
  const response = await fetch(url, { ...options, headers })
  return response.json()
}
```

#### **T·∫°i sao c·∫ßn serverFetch:**
- **V·∫•n ƒë·ªÅ:** Server-side rendering c·∫ßn data t·ª´ API
- **Gi·∫£i ph√°p:** G·ªçi tr·ª±c ti·∫øp t·ª´ server v·ªõi token t·ª´ cookies
- **L·ª£i √≠ch:** Fast SSR, no client-side loading states

## üîÄ Client vs Server Fetch

| Aspect | clientFetch | serverFetch |
|--------|-------------|-------------|
| **Ch·∫°y ·ªü ƒë√¢u** | Browser | Next.js Server |
| **Route** | `/api/users` | `https://api.com/users` |
| **Token source** | Automatic (via proxy) | Server cookies |
| **Middleware** | Qua t·∫•t c·∫£ middleware | Bypass middleware |
| **CORS** | Kh√¥ng v·∫•n ƒë·ªÅ | Kh√¥ng v·∫•n ƒë·ªÅ |
| **Use case** | Client interactions | SSR, SSG |

## üîß Axios Integration

### **T·∫°i sao c·∫ßn Axios:**
- **V·∫•n ƒë·ªÅ:** Native fetch thi·∫øu features
- **Gi·∫£i ph√°p:** Axios v·ªõi interceptors, retry logic
- **L·ª£i √≠ch:** Better error handling, request/response transformation

### **Interceptors:**
```typescript
// Request interceptor
axios.interceptors.request.use(async (config) => {
  // Auto-inject token cho server requests
  if (typeof window === 'undefined') {
    const token = await getServerToken()
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

// Response interceptor
axios.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Handle unauthorized
    }
    return Promise.reject(error)
  }
)
```

## üéØ React Query Integration

### **T·∫°i sao c·∫ßn React Query:**
- **V·∫•n ƒë·ªÅ:** Manual state management cho API calls
- **Gi·∫£i ph√°p:** Automatic caching, background updates, optimistic updates
- **L·ª£i √≠ch:** Better UX, less boilerplate

### **Custom Hooks:**
```typescript
export function useUsers() {
  return useQuery({
    queryKey: ['users'],
    queryFn: () => clientAxiosFetch<User[]>('/users'),
    staleTime: 5 * 60 * 1000, // 5 minutes
    cacheTime: 10 * 60 * 1000, // 10 minutes
  })
}

export function useCreateUser() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: (user: User) => clientAxiosPost('/users', user),
    onSuccess: () => {
      queryClient.invalidateQueries(['users']) // Auto-refresh list
    }
  })
}
```

## üîÑ Request Flow Examples

### **Client-side Request:**
```
1. Browser: clientFetch('/users')
2. Next.js: /api/users
3. Token Middleware: Refresh token n·∫øu c·∫ßn
4. Auth Middleware: Verify user logged in
5. Role Middleware: Check permissions
6. Proxy Middleware: Forward to backend v·ªõi token
7. Backend: Process request
8. Response: Data tr·∫£ v·ªÅ browser
```

### **Server-side Request:**
```
1. Server: serverFetch('/users')
2. Next.js Server: Direct call to backend
3. Get token from cookies
4. Backend: Process request with token
5. Response: Data for SSR
```

## üöÄ Performance Optimizations

### **1. Middleware Optimizations:**
- **Early returns:** Stop middleware chain khi c√≥ redirect
- **Context sharing:** Avoid redundant operations
- **Conditional execution:** Ch·ªâ ch·∫°y khi c·∫ßn thi·∫øt

### **2. API Optimizations:**
- **React Query caching:** Reduce API calls
- **Background updates:** Fresh data without loading states
- **Optimistic updates:** Instant UI updates

### **3. Token Management:**
- **Lazy refresh:** Ch·ªâ refresh khi c·∫ßn
- **Context caching:** Share token across middlewares
- **Secure storage:** httpOnly cookies

## üõ°Ô∏è Security Considerations

### **1. Token Security:**
- **httpOnly cookies:** Prevent XSS attacks
- **Secure flag:** HTTPS only in production
- **SameSite:** CSRF protection

### **2. Request Security:**
- **CORS handled:** Via proxy middleware
- **Token injection:** Automatic, kh√¥ng expose
- **Error handling:** Kh√¥ng leak sensitive info

### **3. Route Protection:**
- **Authentication:** Auth middleware
- **Authorization:** Role middleware
- **Input validation:** Backend responsibility

## üìù Usage Examples

### **Server Component:**
```typescript
// app/users/page.tsx
export default async function UsersPage() {
  const users = await serverFetch<User[]>('/users')
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

### **Client Component:**
```typescript
// components/UserList.tsx
'use client'
export default function UserList() {
  const { data: users, isLoading } = useUsers()
  const createUser = useCreateUser()
  
  if (isLoading) return <div>Loading...</div>
  
  return (
    <div>
      <button onClick={() => createUser.mutate({ name: 'John' })}>
        Add User
      </button>
      {users?.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  )
}
```

## üîß Configuration

### **Environment Variables:**
```bash
# .env.local
API_URL=https://your-backend-api.com
NEXT_PUBLIC_API_URL=https://your-backend-api.com
```

### **Middleware Config:**
```typescript
// middleware.ts
export const config = {
  matcher: [
    '/((?!static|.*\\..*|_next).*)',
  ]
}
```

## üß™ Testing

### **Middleware Testing:**
```typescript
// __tests__/middleware.test.ts
import { tokenApiMiddleware } from '../middlewares/token.middleware'

describe('Token Middleware', () => {
  it('should refresh expired token', async () => {
    const req = createMockRequest({ accessToken: expiredToken })
    const res = NextResponse.next()
    const context = {}
    
    await tokenApiMiddleware.handle(req, res, context)
    
    expect(context.accessToken).toBe(newToken)
  })
})
```

### **API Testing:**
```typescript
// __tests__/api.test.ts
import { clientFetch } from '../lib/api/client'

describe('API Client', () => {
  it('should fetch users successfully', async () => {
    const users = await clientFetch<User[]>('/users')
    expect(users).toHaveLength(2)
  })
})
```

## üéØ Best Practices

### **1. Middleware:**
- Gi·ªØ middleware nh·∫π v√† focused
- S·ª≠ d·ª•ng context ƒë·ªÉ share data
- Early returns cho performance
- Proper error handling

### **2. API Clients:**
- Type-safe v·ªõi TypeScript
- Consistent error handling
- Proper loading states
- Caching strategies

### **3. Security:**
- Never expose sensitive tokens
- Validate inputs
- Use HTTPS in production
- Regular security audits

## üîç Troubleshooting

### **Common Issues:**

#### **1. Token kh√¥ng ƒë∆∞·ª£c refresh:**
```
Nguy√™n nh√¢n: Token middleware kh√¥ng ch·∫°y
Gi·∫£i ph√°p: Ki·ªÉm tra matcher pattern
```

#### **2. CORS errors:**
```
Nguy√™n nh√¢n: G·ªçi tr·ª±c ti·∫øp backend t·ª´ browser
Gi·∫£i ph√°p: S·ª≠ d·ª•ng clientFetch thay v√¨ direct calls
```

#### **3. 401 Unauthorized:**
```
Nguy√™n nh√¢n: Token kh√¥ng ƒë∆∞·ª£c inject
Gi·∫£i ph√°p: Ki·ªÉm tra proxy middleware v√† context
```

## üìö Next Steps

1. **Implement rate limiting** cho API calls
2. **Add request/response logging** cho debugging
3. **Implement retry logic** cho failed requests
4. **Add request deduplication** cho performance
5. **Implement real-time updates** v·ªõi WebSockets

## ü§ù Contributing

1. Fork repository
2. Create feature branch
3. Add tests
4. Submit pull request

## üìÑ License

MIT License - see LICENSE file for details.